<h1><%= link_to 'DND Logger', root_path %> - <%= @log_book.title %></h1>

<%= form_for @entry, :url => entries_path(:log_book_id => @log_book.id) do |f| %>

<%= f.text_area :description %>
<br>
<%= f.submit "Log This!" %>
<%= error_messages_for(f.object) %>

<% end %>

<div class="dropdown">
  <div class="dropdown-content">
  <%= link_to 'All entries', entries_path(:log_book_id => @log_book.id) %> | 
  <%= link_to 'Characters', entries_path(:type_filter => 'characters', :log_book_id => @log_book.id) %> | 
  <%= link_to 'Locations', entries_path(:type_filter => 'locations', :log_book_id => @log_book.id) %>
  </div>
</div>

<h2><%= @filter_type %></h2>

<script src="https://cdn.jsdelivr.net/mark.js/8.6.0/mark.min.js"></script>

<input name="entry_filter" type="text" id="entry_filter" placeholder="Filter...">
<div class="entry_list">

<%= render @entries %>

<div class="entry_list">




<script>

// Create an instance of mark.js and pass an argument containing
// the DOM object of the context (where to search for matches)
var $context = document.querySelectorAll('p.log_entry');
var markInstance = new Mark($context);
// Cache DOM elements
var keywordInput = document.getElementById('entry_filter');
// var optionInputs = document.querySelectorAll("input[name='opt[]']");


function performMark() {

  // Read the keyword
  var keyword = keywordInput.value;

  // Remove previous marked elements and mark
  // the new keyword inside the context
  markInstance.unmark({
  	done: function(){
    	markInstance.mark(keyword);
    }
  });
  filterEntries();
};

// Listen to input and option changes
keywordInput.addEventListener("input", performMark);
// for (var i = 0; i < optionInputs.length; i++) {
//   optionInputs[i].addEventListener("change", performMark);
// }
</script>